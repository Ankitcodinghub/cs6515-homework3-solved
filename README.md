# cs6515-homework3-solved
**TO GET THIS SOLUTION VISIT:** [CS6515 Homework3 Solved](https://www.ankitcodinghub.com/product/cs6515-homework3-solved/)


---

ðŸ“© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
ðŸ“± **WhatsApp:** +1 419 877 7882  
ðŸ“„ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;125894&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;6&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (6 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS6515 Homework3  Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (6 votes)    </div>
    </div>
<strong>Graded Problem</strong>

You are given a directed graph <span class="katex"><span class="katex-mathml">G=(V,E)G = (V, E)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">G</span><span class="mrel">=</span></span><span class="base"><span class="mopen">(</span><span class="mord mathnormal">V</span><span class="mpunct">,</span><span class="mord mathnormal">E</span><span class="mclose">)</span></span></span></span> where every vertex has a label <span class="katex"><span class="katex-mathml">c(v)&gt;0c(v) &gt; 0</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">v</span><span class="mclose">)</span><span class="mrel">&gt;</span></span><span class="base"><span class="mord">0</span></span></span></span>. Design an algorithm to return, for each vertex <span class="katex"><span class="katex-mathml">vv</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">v</span></span></span></span>, the vertex <span class="katex"><span class="katex-mathml">ww</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">w</span></span></span></span> of minimum label reachable from <span class="katex"><span class="katex-mathml">vv</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">v</span></span></span></span>. Here, reachable means there is a path from <span class="katex"><span class="katex-mathml">vv</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">v</span></span></span></span> to <span class="katex"><span class="katex-mathml">ww</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">w</span></span></span></span>. You may assume that <span class="katex"><span class="katex-mathml">vv</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">v</span></span></span></span> is reachable from itself. <em>Faster (in asymptotic Big O notation) and correct solutions are worth more credit.</em>

<hr>
<strong>Instructions</strong>

For the graded problems, you are allowed to use the algorithms from class as black-boxes without further explanation. These include:

<ul>
<li><strong>DFS</strong> which outputs connected components, topological sort on a DAG. You also have access to the prev, pre, and post arrays.</li>
<li><strong>BFS</strong> on unweighted graphs to find the shortest distance from a source vertex to all other vertices and a path can be recovered backtracking over the prev labels.</li>
<li><strong>Dijkstraâ€™s algorithm</strong> on weighted graphs to find the shortest distance from a source vertex to all other vertices and a path can be recovered backtracking over the prev labels.</li>
<li><strong>Bellman-Ford and Floyd-Warshall</strong> to compute the shortest path when weights are allowed to be negative.</li>
<li><strong>SCC</strong> which outputs the strongly connected components, and the metagraph of strongly connected components.</li>
<li><strong>Kruskalâ€™s and Primâ€™s</strong> algorithms to find an MST.</li>
<li><strong>Ford-Fulkerson and Edmonds-Karp</strong> to find the max flow on networks.</li>
<li><strong>2-SAT</strong> which takes a CNF with all clauses of size <span class="katex"><span class="katex-mathml">â‰¤2\leq 2</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mrel">â‰¤</span></span><span class="base"><span class="mord">2</span></span></span></span> and returns a satisfying assignment if it exists.</li>
</ul>
When using a black-box, make sure you clearly describe which input you are passing into it and how you use the output or take advantage of the data structures created by the algorithm. To receive full credit, your solution must:

<ul>
<li><strong>Include the description of your algorithm</strong> in words (no pseudocode!).</li>
<li><strong>Explain the correctness</strong> of your design.</li>
<li><strong>State and analyze the running time</strong> of your design (you can cite and use the running time of black-boxes without further explanations).</li>
</ul>
<strong>Unless otherwise indicated, black-box graph algorithms should be used without modification.</strong>

Example: I take the input graph <span class="katex"><span class="katex-mathml">GG</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">G</span></span></span></span>, I first find the vertex with largest degree, call it <span class="katex"><span class="katex-mathml">vâˆ—v^*</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mord mathnormal">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span>. I take the complement of the graph <span class="katex"><span class="katex-mathml">GG</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">G</span></span></span></span>, call it <span class="katex"><span class="katex-mathml">Gâ€²Gâ€™</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span></span>. Run Dijkstraâ€™s algorithm on <span class="katex"><span class="katex-mathml">Gâ€²Gâ€™</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml">s=vâˆ—s = v^*</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">s</span><span class="mrel">=</span></span><span class="base"><span class="mord"><span class="mord mathnormal">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span></span></span> and then I get the array dist[v] of the shortest path lengths from <span class="katex"><span class="katex-mathml">ss</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">s</span></span></span></span> to every other vertex in the graph <span class="katex"><span class="katex-mathml">Gâ€²Gâ€™</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span></span>. I square each of these distances and return this new array.

<em>We donâ€™t want you to go into the details of these algorithms and tinker with it, just use it as a black-box as shown with Dijkstraâ€™s algorithm above.</em>

<hr>
<strong>Context</strong>

A graph theory problem is a form of <em>reduction</em>. You are given some problem to solve, and the challenge is to solve that problem by using one of the graph algorithms we study this semester. In other words, you <em>reduce</em> your problem to a graph problem such that a known algorithm can solve it for you.

The <em>known algorithms</em> are treated as a black-boxâ€”you are not allowed to change/modify them in any way. You can (and often will) modify the original problem input in some way, or create a graph which represents the inputâ€”this becomes the input to the black-box. You then take the results of running the black-box (both its defined output and the data structures it creates during execution) and use those to deduce the solution to the original problem.

<hr>
<strong>Rules</strong>

<ul>
<li><strong>NO PSEUDOCODE</strong>â€”YOU WILL LOSE A LOT OF POINTS.</li>
<li>Only black-boxes of known algorithms are allowed.</li>
<li>One or more graph black-box <strong>must</strong> be used to solve problems in this section.</li>
<li>Do not make changes to black-boxes unless explicitly allowed. This is very rare and may not happen during the semester.</li>
<li>We consider all graphs to be provided as:
<ul>
<li><span class="katex"><span class="katex-mathml">G=(V,E)G = (V, E)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">G</span><span class="mrel">=</span></span><span class="base"><span class="mopen">(</span><span class="mord mathnormal">V</span><span class="mpunct">,</span><span class="mord mathnormal">E</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml">VV</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">V</span></span></span></span> is an array of vertices</li>
<li><span class="katex"><span class="katex-mathml">EE</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">E</span></span></span></span> is an adjacency list</li>
<li>When a graph is provided as input, you are also given <span class="katex"><span class="katex-mathml">n=âˆ£Vâˆ£n = |V|</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span><span class="mrel">=</span></span><span class="base"><span class="mord">âˆ£</span><span class="mord mathnormal">V</span><span class="mord">âˆ£</span></span></span></span> and <span class="katex"><span class="katex-mathml">m=âˆ£Eâˆ£m = |E|</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">m</span><span class="mrel">=</span></span><span class="base"><span class="mord">âˆ£</span><span class="mord mathnormal">E</span><span class="mord">âˆ£</span></span></span></span>.</li>
</ul>
</li>
</ul>
<hr>
<strong>Components of a complete solution</strong>

(a) <strong>Describe your algorithm</strong>:

<ul>
<li>NO PSEUDOCODEâ€”use words.</li>
<li>What changes you may need for the input.</li>
<li>What black-box you will feed your input to.</li>
<li>What changes you may need for the output.</li>
<li>Repeat with more black-boxes as needed.</li>
</ul>
(b) <strong>Justify why your algorithm is correct</strong>:

<ul>
<li>Explain how your problem is solved by the black-boxes used.</li>
<li>Explain how changing the inputs and/or outputs gets what you want.</li>
</ul>
(c) <strong>Analyze the runtime</strong>:

<ul>
<li>Must be presented in Big O notation.</li>
<li>Can explain/analyze in words.</li>
<li>Can use known black-box runtime without explanation. Must include runtime analysis for any pre/post-processing, as well as any modifications to the black-box (if permitted by the problem).</li>
<li>Again, if we give you a runtime, you must meet that for full credit. If we do not specify a runtime, faster (and correct) in Big O notation are worth more credit.</li>
</ul>
